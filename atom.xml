<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cyang&#39;s blog</title>
  <subtitle>just do IT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.cyang.tech/"/>
  <updated>2018-11-11T14:11:26.317Z</updated>
  <id>https://blog.cyang.tech/</id>
  
  <author>
    <name>cyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IAR开发STM32堆栈设置</title>
    <link href="https://blog.cyang.tech/2018/10/25/IAR%E5%BC%80%E5%8F%91STM32%E5%A0%86%E6%A0%88%E8%AE%BE%E7%BD%AE/"/>
    <id>https://blog.cyang.tech/2018/10/25/IAR开发STM32堆栈设置/</id>
    <published>2018-10-25T14:31:19.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>关于堆栈的定义在此就不赘述，详细内容可以看<a href="https://blog.csdn.net/u011303443/article/details/78989683" target="_blank" rel="external">这篇博客</a>。<br>堆栈溢出会导致野指针，返回地址错误等问题，通常程序已经无法正常运行，进入 HardFault 异常中断。为了避免这种情况，一般会分配较大的空间用做栈，可是如果仅仅为了安全就分配大空间的栈势必导致内存浪费。本文介绍两种获取栈最大消耗的方法，以方便合理设置栈的大小。</p>
<a id="more"></a>
<h1 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h1><h2 id="1、方法一"><a href="#1、方法一" class="headerlink" title="1、方法一"></a>1、方法一</h2><p>栈指针 SP 指向的位置可以反应出当前栈的消耗量。在 STM32 中，栈是向下生长的，如果我们定期的获取栈指针 SP 的值，比较后得到一个最小值，就代表了栈的最大消耗量。而如何才能定期去获取栈指针 SP 的值呢？可以使用定时器产生一个周期性的中断，在中段函数中获取栈指针 SP 的值。最简单的方法就是在系统滴答定时器（SysTick）的中断函数中调用栈分析函数。具体可以参看如下的函数。在程序运行结束后，再去获取最大栈消耗量。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> uint32_t max_stack_usage <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">stack_parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token operator">&amp;</span>a <span class="token operator">&lt;</span> max_stack_usage<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        max_stack_usage <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

uint32_t <span class="token function">get_max_stack_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> max_stack_usage<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这个函数是周期执行的，必然对程序的运行性能产生影响，不过这只是为了分析，最终是要移除的。另外由于是周期执行，所以可能会错过一些周期性的压栈，以至于获取的数值并不是最大值。不过，这种方法还是有它的参考意义的。</p>
<h2 id="2、方法二"><a href="#2、方法二" class="headerlink" title="2、方法二"></a>2、方法二</h2><p>在 IAR 中，可以开启栈使用分析(IAR Embedded Workbench Stack Usage Analysis)，让 IDE 在编译链接阶段就推算出这个程序的栈最大使用量。不过这种方法无法分析使用函数指针的方式调用的函数，也不能确定递归函数的嵌套次数，因此这两种情况下需要使用配置文件来指出这种调用的压栈空间，比较麻烦，具体可看<a href="https://www.iar.com/support/resources/articles/detecting-and-avoiding-stack-overflow-in-embedded-systems/" target="_blank" rel="external">官方手册</a>。不过函数指针和递归函数毕竟是少数情况，大多数的函数都是显示调用的。因此 IDE 会分析出一条最长的调用路径，从而分析出最大的栈使用量。步骤如下：</p>
<blockquote>
<p>1、开启 options &gt; linker &gt;Advanced &gt; Enable stack usage analysis<br>2、编译后查看 map 文件中的 STACK USAGE 部分</p>
</blockquote>
<p>内容类似于：</p>
<pre><code>*******************************************************************************
*** STACK USAGE
***

  Call Graph Root Category  Max Use  Total Use
  ------------------------  -------  ---------
  Program entry              8 600      8 600
  Uncalled function            256      1 332
</code></pre><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p> 栈空间用来存放局部变量，部分函数参数，返回地址，以及保存函数调用时主调函数的寄存器内容等。为了减少栈的分配，一定要注意不要在函数中放置很大的局部数组。上文所需的 8600 字节的栈空间，就是因为程序中有一个函数中分配了一个 8192 字节的数组，如下。</p>
<pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">decode_subframe_lpc</span><span class="token punctuation">(</span>FLACContext <span class="token operator">*</span>s<span class="token punctuation">,</span> int32_t<span class="token operator">*</span> decoded<span class="token punctuation">,</span> <span class="token keyword">int</span> pred_order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    int64_t wsum<span class="token punctuation">;</span>
    <span class="token keyword">int</span> coeff_prec<span class="token punctuation">,</span> qlevel<span class="token punctuation">;</span>
    <span class="token keyword">int</span> coeffs<span class="token punctuation">[</span><span class="token number">2048</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//8k, use heap to save stack</span>
    int32_t<span class="token operator">*</span> output<span class="token punctuation">;</span>
    int32_t<span class="token operator">*</span> reader<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> pcoeffs<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用两种方式来修改。其一，将 coeffs 这个数据变成 static 局部静态变量，这样做可以将这个变量从栈中移到 .bss 区域中，不过这种方式并不灵活，相当于 8192 B 的空间被占用，而其他函数无法使用。所以本质上和放在栈空间中区别不大。其二是通过 malloc 的方式灵活申请和释放内存，当不在需要这部分空间时，可以将其释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;关于堆栈的定义在此就不赘述，详细内容可以看&lt;a href=&quot;https://blog.csdn.net/u011303443/article/details/78989683&quot;&gt;这篇博客&lt;/a&gt;。&lt;br&gt;堆栈溢出会导致野指针，返回地址错误等问题，通常程序已经无法正常运行，进入 HardFault 异常中断。为了避免这种情况，一般会分配较大的空间用做栈，可是如果仅仅为了安全就分配大空间的栈势必导致内存浪费。本文介绍两种获取栈最大消耗的方法，以方便合理设置栈的大小。&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="IAR" scheme="https://blog.cyang.tech/tags/IAR/"/>
    
      <category term="STACK" scheme="https://blog.cyang.tech/tags/STACK/"/>
    
      <category term="堆栈" scheme="https://blog.cyang.tech/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>汇编文件从 Keil 移植到 IAR</title>
    <link href="https://blog.cyang.tech/2018/10/19/%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E4%BB%8E%20keil%20%E7%A7%BB%E6%A4%8D%E5%88%B0%20IAR/"/>
    <id>https://blog.cyang.tech/2018/10/19/汇编文件从 keil 移植到 IAR/</id>
    <published>2018-10-19T11:37:19.000Z</published>
    <updated>2018-11-11T14:11:26.321Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>汇编文件移植性比较差，不同的内核架构支持的指令集都不一样，就算是相同的内核，在不同的 IDE 下的写法也有可能不一样。同样的文件在 KEIL 下可以正常运行，在 IAR 下就无法编译通过，这就是因为 KEIL 和 IAR 对汇编文件的写法要求是不一样的。KEIL 以及 ADS 下的一些伪指令和写法，在 IAR 下是不支持或者不一样的。具体可以参考 <a href="http://ftp.iar.se/WWWfiles/arm/webic/doc/EWARM_ADSMigrationGuide.ENU.pdf" target="_blank" rel="external">《EWARM_ADSMigrationGuide.ENU.pdf》</a>，下文只是我自己在移植过程中的一些修改记录。</p>
<a id="more"></a>
<h1 id="二、修改方法"><a href="#二、修改方法" class="headerlink" title="二、修改方法"></a>二、修改方法</h1><ul>
<li><p>1、修改段和区域的写法</p>
<p>系统段和区域在 ADS 下定义为 AREA，在 IAR 下定义为 RSEG，因此需要做如下更改。</p>
<blockquote>
<p>keil 下的写法</p>
<pre class="line-numbers language-asm"><code class="language-asm">AREA |.text|, CODE, READONLY, ALIGN=2
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>IAR 下的写法</p>
<pre class="line-numbers language-asm"><code class="language-asm">RSEG CODE:CODE:NOROOT(2)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
</li>
<li><p>2、修改 RN 伪指令</p>
<p>在 ADS 中，可以使用语句 <code>name RN Rn</code> 来给 寄存器 Rn 重命名为 name，在 IAR 下不支持这种写法，因此需要将汇编文件中所有用到的 name 替换回 Rn。类似下面的修改：</p>
<blockquote>
<p>keil 下的写法</p>
</blockquote>
<pre class="line-numbers language-asm"><code class="language-asm">PCM RN r0  ;rename

ldr PCM, [sp, #4] ; load pcm pointer
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>IAR 下的写法</p>
<pre class="line-numbers language-asm"><code class="language-asm">ldr r0, [sp, #4] ; load pcm pointer
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
</li>
<li><p>3、修改宏的写法</p>
<p>ADS 下的宏结束标志和 IAR 下是不同的，另外写法也不一样。具体如下：</p>
<blockquote>
<p>keil 下的写法<br>```asm<br>MACRO</p>
<pre><code>MC0S $x
</code></pre><p>ldr r12, [r2], #4<br>ldr r14, [r2], #4<br>ldr r0, [r1, #(4<em>($x))]<br>ldr r3, [r1, #(4</em>(23 - $x))]</p>
</blockquote>
<p>…</p>
<p>MEND ; MCOS</p>
<pre><code>
&gt; IAR 下的写法
```asm
MC0S MACRO x

    ldr r12, [r2], #4
    ldr r14, [r2], #4
    ldr r0, [r1, #(4*(x))]
    ldr r3, [r1, #(4*(23 - x))]

...

    ENDM ; MCOS
</code></pre></li>
<li><p>4、删除 PROC、ENP、GBLA 等伪指令。这些指令在 IAR 下不支持，编译无法通过。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;汇编文件移植性比较差，不同的内核架构支持的指令集都不一样，就算是相同的内核，在不同的 IDE 下的写法也有可能不一样。同样的文件在 KEIL 下可以正常运行，在 IAR 下就无法编译通过，这就是因为 KEIL 和 IAR 对汇编文件的写法要求是不一样的。KEIL 以及 ADS 下的一些伪指令和写法，在 IAR 下是不支持或者不一样的。具体可以参考 &lt;a href=&quot;http://ftp.iar.se/WWWfiles/arm/webic/doc/EWARM_ADSMigrationGuide.ENU.pdf&quot;&gt;《EWARM_ADSMigrationGuide.ENU.pdf》&lt;/a&gt;，下文只是我自己在移植过程中的一些修改记录。&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="IAR" scheme="https://blog.cyang.tech/tags/IAR/"/>
    
      <category term="keil" scheme="https://blog.cyang.tech/tags/keil/"/>
    
      <category term="ASM" scheme="https://blog.cyang.tech/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Ide 与 Leetcode 运行结果不一样</title>
    <link href="https://blog.cyang.tech/2018/09/16/ide%20%E4%B8%8E%20leetcode%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E6%A0%B7/"/>
    <id>https://blog.cyang.tech/2018/09/16/ide 与 leetcode 运行结果不一样/</id>
    <published>2018-09-16T04:57:19.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>在做 leetcode 的<a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="external">第 15 题</a>， <code>3Sum</code> 时发现，同样的代码在本地运行的结果是正确的，而在 leetcode 的服务器上结果却是错误的。而且检查了程序中，也并没有使用全局或者静态变量。</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/leetcode/diff.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<p>通过打印，仔细对比两种环境下的输出发现，原来是代码有一条语句指针指向了数组外边的第一个地址。语句的内容是比较当前地址的值是否和后一个地址的值相同， 由于后一个地址实际上已经发生了溢出，在当前地址为数组最后一个元素时，下一个地址就在数组外边了，这个地址的值是不确定的。在本地调试时，由于两个地址的值不同，所以程序结果正确，而在 leetcode 服务器上运行时，这两个值相同，因此程序最终的结果就错误了。</p>
<a id="more"></a>
<p><img src="http://p7tst3obo.bkt.clouddn.com/leetcode/debug.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<p>下面是完整代码，出错的代码在第 62 行。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*
* @Author: cyang
* @Date:   2018-08-06 16:26:59
* @Last Modified by:   cyang
* @Last Modified time: 2018-09-15 14:55:12
*/</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">cmpfunc</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>a <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>b <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * Return an array of arrays of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>return_array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> numsSize <span class="token operator">*</span> <span class="token punctuation">(</span>numsSize<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmpfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rerurn_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token number">-2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"=======================================\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        start <span class="token operator">=</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        end <span class="token operator">=</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">[</span>numsSize<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
            temp <span class="token operator">=</span> <span class="token operator">*</span>start <span class="token operator">+</span> <span class="token operator">*</span>end <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// printf("%d %d %d %d \n", i, nums[i], *start, *end);</span>
                return_array<span class="token punctuation">[</span>rerurn_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                return_array<span class="token punctuation">[</span>rerurn_size<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                return_array<span class="token punctuation">[</span>rerurn_size<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>start<span class="token punctuation">;</span>
                return_array<span class="token punctuation">[</span>rerurn_size<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>

                rerurn_size<span class="token operator">++</span><span class="token punctuation">;</span>

                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>start <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"+\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    start<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token macro property">#<span class="token directive keyword">if</span> 1 </span><span class="token comment" spellcheck="true">//ringht</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>end <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>end <span class="token operator">!=</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">[</span>numsSize<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token macro property">#<span class="token directive keyword">else</span> </span><span class="token comment" spellcheck="true">//wrong</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>end <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token macro property">#<span class="token directive keyword">endif</span></span>
                <span class="token punctuation">{</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    end<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                start<span class="token operator">++</span><span class="token punctuation">;</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                start<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// > 0</span>
            <span class="token punctuation">{</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p, %p\n"</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token operator">*</span>returnSize <span class="token operator">=</span> rerurn_size<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rerurn_size = %d\n"</span><span class="token punctuation">,</span> rerurn_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> return_array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// int nums[] = {-1, 0, 1, 2, -1, -4};</span>
    <span class="token comment" spellcheck="true">// int nums[] = {0, 0, 0, 0};</span>
    <span class="token comment" spellcheck="true">// int nums[] = {1, -1, -1, 0};</span>
    <span class="token comment" spellcheck="true">// int nums[] = {-2, 0, 0, 2, 2};</span>
    <span class="token comment" spellcheck="true">// int nums[] = {-2, 0, 1, 1, 2};</span>
    <span class="token comment" spellcheck="true">// int nums[] = {1, -4, -4, 2, 0, 0, -2, 3, 3, -3, -4};</span>

    <span class="token keyword">int</span> numsSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>return_array <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    return_array <span class="token operator">=</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>returnSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>return_array <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> returnSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> return_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> returnSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>return_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// system("pause");</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做 leetcode 的&lt;a href=&quot;https://leetcode.com/problems/3sum/description/&quot;&gt;第 15 题&lt;/a&gt;， &lt;code&gt;3Sum&lt;/code&gt; 时发现，同样的代码在本地运行的结果是正确的，而在 leetcode 的服务器上结果却是错误的。而且检查了程序中，也并没有使用全局或者静态变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7tst3obo.bkt.clouddn.com/leetcode/diff.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过打印，仔细对比两种环境下的输出发现，原来是代码有一条语句指针指向了数组外边的第一个地址。语句的内容是比较当前地址的值是否和后一个地址的值相同， 由于后一个地址实际上已经发生了溢出，在当前地址为数组最后一个元素时，下一个地址就在数组外边了，这个地址的值是不确定的。在本地调试时，由于两个地址的值不同，所以程序结果正确，而在 leetcode 服务器上运行时，这两个值相同，因此程序最终的结果就错误了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="leetcode" scheme="https://blog.cyang.tech/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>J-Link V9 修复记录</title>
    <link href="https://blog.cyang.tech/2018/09/13/j-link%20v9%20%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.cyang.tech/2018/09/13/j-link v9 修复记录/</id>
    <published>2018-09-13T11:19:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="j-link-v9"><a href="#j-link-v9" class="headerlink" title="j-link v9"></a>j-link v9</h1><p>主控: stm32f205RC</p>
<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><ul>
<li>1、给 M0 下载固件的过程中经常出错，提示找不到M0。需要反复尝试很多次才可以下载。</li>
<li>2、在一次正常的拔线断电后，再也无法识别，灯也不亮了。</li>
</ul>
<a id="more"></a>
<h1 id="修复方法一"><a href="#修复方法一" class="headerlink" title="修复方法一"></a>修复方法一</h1><ul>
<li>1、准备另一个可以使用的 j-link。这里使用的就是这种只有四根线，只支持 SWD 的 j-link OB。</li>
<li>2、拆开坏了的 j-link v9， 可以看到 PCB 上留有四个圆孔，分别是 VCC，GND， SCK，SWD。具体的位置要看对应的原理图，因为有很多不同的 j-link 。</li>
<li><p>3、使用 SWD 的方式连接好的 j-link 和 坏的 j-link 。<br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/pic.jpg?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
<li><p>4、打开 j-flash， 新建项目，配置芯片为 STM32F205RC，使用 SWD 接口，点击连接。如果无法连接，可能是上一部四条线没有接对，可更改后在尝试。也不可以不用新建项目，直接用 j-flash 打开 <code>restore.jflash</code>。<br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/new.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"><br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/choose.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
<li><p>5、点击 file, 选择 open data file，打开恢复固件 <code>JLinkAll.hex</code>。</p>
</li>
<li><p>6、下载固件，完成修复。<br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/program.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"><br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/succ.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"><br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/end.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
<li><p>7、完成之后，j-link v9 就修复了，可正常使用了。<br><img src="http://p7tst3obo.bkt.clouddn.com/j-link/download.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
</ul>
<h1 id="修复方法二"><a href="#修复方法二" class="headerlink" title="修复方法二"></a>修复方法二</h1><ul>
<li>1、前面连接的方法和方法一相同，区别在于下载的东西不同。方法一中下载的固件是完整的，版本比较旧，大概是14年的版本，但是也可以用。</li>
<li>2、也可以只烧写一个 bootloader 到掉固件的j-link， 烧写方法如上，也是需要一个好的 j-link， 使用 SWD 接口和坏的 j-link 相连， 使用 j-flash 下载。bootloader 文件见末尾方法二附件。</li>
<li>3、下载完成后，将旧的 j-link 和电脑连接，打开 j-link commeder 这个软件。会提示固件需要更新，之后就会自动下载并更新固件。</li>
<li>4、之后可以看到 j-link 的 SN 为 -1，表示还未配置 SN，可使用如下命令配置。同时可添加一些特性，代码如下。<br>```<br>在JLINK的command下依次运行如下命令  </li>
</ul>
<p>Exec SetSN=XXXXXXXX      ;添加SN<br>Exec AddFeature GDB      ;添加GDB<br>Exec AddFeature RDI      ;添加RDI<br>Exec AddFeature FlashBP  ;添加FlashBP<br>Exec AddFeature FlashDL  ;添加FlashDL<br>Exec AddFeature JFlash   ;添加JFlash<br>Exec AddFeature RDDI     ;添加RDDI<br>```</p>
<p><a href="https://download.csdn.net/download/u011303443/10664113" target="_blank" rel="external">方法一附件下载</a><br><a href="https://download.csdn.net/download/u011303443/10666798" target="_blank" rel="external">方法二附件下载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;j-link-v9&quot;&gt;&lt;a href=&quot;#j-link-v9&quot; class=&quot;headerlink&quot; title=&quot;j-link v9&quot;&gt;&lt;/a&gt;j-link v9&lt;/h1&gt;&lt;p&gt;主控: stm32f205RC&lt;/p&gt;
&lt;h1 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1、给 M0 下载固件的过程中经常出错，提示找不到M0。需要反复尝试很多次才可以下载。&lt;/li&gt;
&lt;li&gt;2、在一次正常的拔线断电后，再也无法识别，灯也不亮了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="j-link" scheme="https://blog.cyang.tech/tags/j-link/"/>
    
      <category term="stm32" scheme="https://blog.cyang.tech/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>MPEG 简述</title>
    <link href="https://blog.cyang.tech/2018/08/12/MPEG%20%E7%AE%80%E8%BF%B0/"/>
    <id>https://blog.cyang.tech/2018/08/12/MPEG 简述/</id>
    <published>2018-08-12T08:18:19.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="MPEG-AUDIO-简介"><a href="#MPEG-AUDIO-简介" class="headerlink" title="MPEG AUDIO 简介"></a>MPEG AUDIO 简介</h1><p>MP3 是 MPEG Layer3 音频压缩技术的简写，这种技术可在音质极少损伤的情况下获取更好的压缩性能。MP3文件可以被压缩成不同的速率，文件压缩的越小，音质损伤越大。标准的压缩比例为10：1，一段3分钟的音频数据压缩后只需4MB大小。<br><a id="more"></a></p>
<p>MPEG 音频压缩算法由联合图像专家组开发，作为高质量数字音频数据压缩的国际标准。MPEG-1 音频压缩算法基于两种机理来减少音频信号码率额，一是利用统计相关性，去除音频信号的冗余，二是利用人耳的心理声学现象如频率掩蔽和时间掩蔽等，去除听觉冗余。分为三个层次，分别是 layer1,layer2,layer3，每个层次针对不同的应用，但是三个层次的基本模型是相同的，每个后继的层都有更高的压缩比，但是需要更加复杂的编解码器。</p>
<p>更新的版本是 MPEG-2，这个版本扩展了MPEG-1的采样率标准，在 MPEG-1 的 32kHz,44.1kHz, 48kHz 的基础上，支持16kHz,22.05kHz,24kHz 采样率。并且MPEG-2还支持多通道。</p>
<p>有一个非官方的标准MPEG-2.5，支持更低的采样率，支持8KHz，11.025kHz 和 12KHz。</p>
<h1 id="MP3-bitstream-概述"><a href="#MP3-bitstream-概述" class="headerlink" title="MP3 bitstream 概述"></a>MP3 bitstream 概述</h1><p>广泛使用的MP3指的是不论MPEG哪个版本的layer3的编码，然而，有时候MP3也泛指了所有的MPEG算法。<br>MPP3 的音频流具有固定可选的码率。根据不同的采样率和 layer 可选的 bitrate 不同，具体见下表。也允许对流中不同的部分使用不同的码率，称为“VBR”。<br><img src="http://p7tst3obo.bkt.clouddn.com/MPEG/bitrate.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>MP3编码压缩后的数据是由一系列固定大小的块组成的，这些块叫做帧。每一帧具有多少的PCM采样数据是固定的，见下表。解码时必须从帧头开始解，但可以只解一部分，可解的最小单元数见下表。<br><img src="http://p7tst3obo.bkt.clouddn.com/MPEG/sample.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>帧的格式见下图，帧头是32位的数据，用于同步一些基本的信息。例如采样率，通道数，比特率之类。16位的CRC校验值是可选的。注意，CRC校验的并不是整个帧的数据，仅仅是帧头数据的后16位和辅助信息的校验。<br><img src="http://p7tst3obo.bkt.clouddn.com/MPEG/frame.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt=""></p>
<p>MPEG的音频文件没有主要的文件头。一个MPEG文件是由一系列的标准帧组成的。帧与帧之间不能有任何的垃圾数据。帧的大小可从帧头信息中获得，因此如果知道前一帧头位置可以很容易得到下一帧的帧头位置。为了支持更多的自定义格式，解码器必须连续读取几个帧头，以便计算出该音频一帧的长度。在使用自定义模式时，不可使用VBR模式，且不可以和固定大小的帧混合。</p>
<p>在Layer1和Layer2中，帧是相对独立的。每一帧都包含了足够解码使用的信息，所以解码器只要在数据流中正确解出一个帧头后就可以完成工作。但是在Layer3中，帧不总是独立的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MPEG-AUDIO-简介&quot;&gt;&lt;a href=&quot;#MPEG-AUDIO-简介&quot; class=&quot;headerlink&quot; title=&quot;MPEG AUDIO 简介&quot;&gt;&lt;/a&gt;MPEG AUDIO 简介&lt;/h1&gt;&lt;p&gt;MP3 是 MPEG Layer3 音频压缩技术的简写，这种技术可在音质极少损伤的情况下获取更好的压缩性能。MP3文件可以被压缩成不同的速率，文件压缩的越小，音质损伤越大。标准的压缩比例为10：1，一段3分钟的音频数据压缩后只需4MB大小。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="https://blog.cyang.tech/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Audio" scheme="https://blog.cyang.tech/tags/Audio/"/>
    
      <category term="MPEG" scheme="https://blog.cyang.tech/tags/MPEG/"/>
    
      <category term="MP3" scheme="https://blog.cyang.tech/tags/MP3/"/>
    
  </entry>
  
  <entry>
    <title>前导零计数</title>
    <link href="https://blog.cyang.tech/2018/08/02/%E5%89%8D%E5%AF%BC%E9%9B%B6%E8%AE%A1%E6%95%B0/"/>
    <id>https://blog.cyang.tech/2018/08/02/前导零计数/</id>
    <published>2018-08-02T11:58:19.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="前导零计数"><a href="#前导零计数" class="headerlink" title="前导零计数"></a>前导零计数</h1><p>计算一个 32位 数头部 0 的个数。例如 1 前面有 31 个0， 0 则前面有 32 个0。</p>
<a id="more"></a>
<h2 id="C-语言实现"><a href="#C-语言实现" class="headerlink" title="C 语言实现"></a>C 语言实现</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cntLeadingZeros</span><span class="token punctuation">(</span>uint32_t i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    uint32_t temp <span class="token operator">=</span> <span class="token operator">~</span>i<span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        temp <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        ret<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="硬件指令"><a href="#硬件指令" class="headerlink" title="硬件指令"></a>硬件指令</h2><p>在 ARM 和 Xtensa 架构的硬件中，具有单独的指令可以完成前导0计算。<br>在 ARM 下是 <code>clz</code> 指令； 在 Xtensa 下是 <code>NSAU</code> 指令，用法一样。</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/clz/arm.jpg?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="ARM"><br><img src="http://p7tst3obo.bkt.clouddn.com/clz/xtensa.jpg?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="xtensa"></p>
<h3 id="内嵌汇编实现"><a href="#内嵌汇编实现" class="headerlink" title="内嵌汇编实现"></a>内嵌汇编实现</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cntLeadingZeros</span><span class="token punctuation">(</span>uint32_t i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"clz %0, %1 "</span><span class="token punctuation">:</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string">"r"</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//arm</span>
    <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"nsau %0, %1 "</span><span class="token punctuation">:</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string">"r"</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//xtensa</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode.com/problems/number-complement/description/" target="_blank" rel="external">leetcode 题目 476</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前导零计数&quot;&gt;&lt;a href=&quot;#前导零计数&quot; class=&quot;headerlink&quot; title=&quot;前导零计数&quot;&gt;&lt;/a&gt;前导零计数&lt;/h1&gt;&lt;p&gt;计算一个 32位 数头部 0 的个数。例如 1 前面有 31 个0， 0 则前面有 32 个0。&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="Xtensa" scheme="https://blog.cyang.tech/tags/Xtensa/"/>
    
      <category term="ARM" scheme="https://blog.cyang.tech/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>Fread 返回 0</title>
    <link href="https://blog.cyang.tech/2018/07/25/fread%20%E8%BF%94%E5%9B%9E%200/"/>
    <id>https://blog.cyang.tech/2018/07/25/fread 返回 0/</id>
    <published>2018-07-25T12:56:19.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>fread 函数一直返回 0，检查过读取的数量不会超过文件大小，错误发生在打开文件时错误。</p>
<p>错误代码如下：</p>
<pre class="line-numbers language-c"><code class="language-c">FILE <span class="token operator">*</span>in_file<span class="token punctuation">,</span> <span class="token operator">*</span>out_file<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">open_files</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>in_file_name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>out_file_name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> in_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>in_file_name<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span> out_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>out_file_name<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<a id="more"></a>
<p>正确应该是：</p>
<pre class="line-numbers language-c"><code class="language-c">FILE <span class="token operator">*</span>in_file<span class="token punctuation">,</span> <span class="token operator">*</span>out_file<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">open_files</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>in_file_name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>out_file_name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>in_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>in_file_name<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>out_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>out_file_name<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>错误的原因在于没有使用括号，而比较运算符 == 的优先级比赋值运算符 = 要高。因此，错误的程序执行结果为，函数正常打开了文件，返回的文件指针与 NULL 相比为0，赋值给了 in_file, if 不会执行，因此误以为 in_file 是文件指针，实际上为0，所以无法读出数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fread 函数一直返回 0，检查过读取的数量不会超过文件大小，错误发生在打开文件时错误。&lt;/p&gt;
&lt;p&gt;错误代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;FILE *in_file, *out_file;
unsigned int open_files(const char *in_file_name, const char *out_file_name)
{
    if( in_file = fopen(in_file_name, &amp;quot;rb&amp;quot;) == NULL)

        return 0;

    if( out_file = fopen(out_file_name, &amp;quot;wb&amp;quot;) == NULL)

        return 0;

    return 1;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>记一款游戏--《程序员升职记》</title>
    <link href="https://blog.cyang.tech/2018/07/21/%E8%AE%B0%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F--%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8D%87%E8%81%8C%E8%AE%B0%E3%80%8B/"/>
    <id>https://blog.cyang.tech/2018/07/21/记一款游戏--《程序员升职记》/</id>
    <published>2018-07-21T14:39:19.000Z</published>
    <updated>2018-11-11T14:11:26.321Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><img src="http://p7tst3obo.bkt.clouddn.com/hrm/main.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="main"></p>
<p>最近在玩一款编程类的游戏，叫做《程序员升职记》，steam 平台只需￥36。通过组合几条非常基本的指令，例如加减、自加、自减、比较、跳转，实现一些小功能，例如简单的数值绝对值输出、两数乘法、阶乘运算、反转字符串等。游戏的本质是一款支持 11 条指令，最多支持 24 字节内存的 8 位 cpu 的运行。</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/hrm/level.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="level"></p>
<p>这款游戏前面的一些关卡主要在引导和介绍游戏，同时不断给出新的指令，开始只有简单的几条指令，后面会加入对内存的使用，间接寻址的使用，因此可以实现指针的操作。每一关都会给出随机的输入，经过你编写的程序后，算出符合要求的输出。编写程序的过程可以通过单步运行来调试，所以可以很快知道程序在哪里出错，并修改。</p>
<a id="more"></a>
<p><img src="http://p7tst3obo.bkt.clouddn.com/hrm/asm.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="asm"></p>
<p>这款游戏可以很好地帮助你理解 CPU 的运行原理，编写的程序其实就是汇编程序，每一条指令都可以对应到一条汇编指令。通过复制指令到记事本也可以看出。关卡的输入每一次都是随机出现的，这就要求程序要在任何合理的输入下都可以正确运行，而不是当前给定的输入。这款游戏又不像我之前玩过的另一款手机上的编程类游戏–light robot。这款游戏在指令的条数上没有任何限制，也就是说你可以使用不限数量的指令来实现你的程序，但另一方面游戏非常鼓励你找到一种最优解，使得指令条数和运算次数都尽可能的少，这意味着程序所需的代码空间很少，同时运算速度又最快。所以你可以先按照你对这个题目的解题思路来实现这个程序，等程序完美运行没有出错后，再来考虑怎么优化程序。light robot 是一款通过组合指令来实现不同的点灯效果的游戏，但是这个游戏是限制指令数量的，因此你不能先实现再进行优化，你必须一来就找到最优解，这让我在后面的关卡无法继续。</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/hrm/light-robot.jpg?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="light robot"></p>
<p>这款游戏还有一个特点就是支持单步调试，通过单步运行，可以很快看出运行出错的地方，结合指令，可以很快看出错误。在简单的测试没有出错之后，又可以全速运行程序，完成题目。因为所有的题目基本上都是需要通过跳转来实现循环结构的，这样可以实现不停的输入。而在你刚开始编写的程序中，很可能是没有考虑到所有情况的，可能这组输入运算正确，而到了下一组就不正确了。因此通过单步，中断运行，回退指令可以查看运算错误的原因，这和平常的开发也很像。</p>
<p>开头说了，这款游戏的解题过程其实就是一款简单 CPU 运行的过程。这款 CPU 最多支持11条指令，可以分为四类。第一类基本输入输出 input/output，第二类对内存的读写 copyfrom/copyto，第三类加减运算，包括加减一个数，和一个数自加一和自减一，第四类跳转指令，包括无条件跳转、值为零跳转、值为负跳转。第一类和第四类指令的运行不需要提供参数，指令的运行仅影响 CPU 寄存器或者仅受 CPU 寄存器的影响。而第二类和第三类的指令是需要提供一个参数的，刚开始这个参数是一个值，后面的关卡中加入了间接寻址，可以通过类似指针的操作来实现更多的功能，因此第二类和第三类指令的参数也支持地址参数。</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/hrm/game.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="game"></p>
<p>根据关卡的不同，可以用的内存大小（地毯数量）是不同的，最多的时候有 24 字节，有时候地毯上是有值的，类似于C语言中带初值的全局变量。对内存的使用主要是读写，而且不允许对一个空的内存执行读操作，因为此时该值是未知的。内存用来暂存一些程序运行时的中间数据。很多关卡都会在内存中给一个 0 值，因为 CPU 不支持立即寻址，因此将 0 值通过内存的方式给定，0 值经常被用于计数，因此你可能需要在程序的开始将其复制到另一块内存中，以确保下一次的输入还是可以拷贝一个 0，并从 0 开始计数。</p>
<p>这款游戏的编程语言是汇编，从程序执行结构上来说就只有两种，一种是顺序结构，另一种是选择结构，而循环结构则是需要通过选择结构和跳转指令来实现的。但由于跳转指令只有三条，带条件的只有值为零和值为负两种，也就是说在做某些题是需要判断值为正的，则需要进行对应的转换。在后面的关卡中，出现的题目比较复杂，需要采用子程序的设计来实现，类似于函数的概念。有一关里面甚至给出了一小段程序。</p>
<p>这款游戏的关卡不是很多，通关也不会花费很长的时间，但是程序给出了一个最优解的标准，对指令数量和运行次数的最大值给以限制，想要每一关都可以实现最优解也是需要费一番功夫的。另外游戏本身是有一条故事线的，虽然关系并不大，但是聊胜于无。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p7tst3obo.bkt.clouddn.com/hrm/main.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;main&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在玩一款编程类的游戏，叫做《程序员升职记》，steam 平台只需￥36。通过组合几条非常基本的指令，例如加减、自加、自减、比较、跳转，实现一些小功能，例如简单的数值绝对值输出、两数乘法、阶乘运算、反转字符串等。游戏的本质是一款支持 11 条指令，最多支持 24 字节内存的 8 位 cpu 的运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7tst3obo.bkt.clouddn.com/hrm/level.png?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;level&quot;&gt;&lt;/p&gt;
&lt;p&gt;这款游戏前面的一些关卡主要在引导和介绍游戏，同时不断给出新的指令，开始只有简单的几条指令，后面会加入对内存的使用，间接寻址的使用，因此可以实现指针的操作。每一关都会给出随机的输入，经过你编写的程序后，算出符合要求的输出。编写程序的过程可以通过单步运行来调试，所以可以很快知道程序在哪里出错，并修改。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="游戏" scheme="https://blog.cyang.tech/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="汇编" scheme="https://blog.cyang.tech/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>PCM 转 WAV pcmToWav</title>
    <link href="https://blog.cyang.tech/2018/06/07/pcmToWav/"/>
    <id>https://blog.cyang.tech/2018/06/07/pcmToWav/</id>
    <published>2018-06-07T11:45:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>PCM 数据无法直接通过播放器打开，因为少了 44 字节的文件头，这里面最主要的信息是描述该 PCM 的采样频率，通道数，以及位数。</p>
<p>双击 pcmToWav.exe，拖入待转换的 PCM 数据，输入通道数和采样频率，默认使用 16-bit 表示一个采样点。等待程序运行结束，就会生成一个同名的 .wav 文件。</p>
<a id="more"></a>
<p><img src="http://p7tst3obo.bkt.clouddn.com/20180607194104253?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<p>python 源码</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>
<span class="token comment" spellcheck="true"># @Author: cyang</span>
<span class="token comment" spellcheck="true"># @Date:   2018-06-07 11:30:01</span>
<span class="token comment" spellcheck="true"># @Last Modified by:   cyang</span>
<span class="token comment" spellcheck="true"># @Last Modified time: 2018-06-07 14:43:23</span>

<span class="token keyword">import</span> os
<span class="token keyword">import</span> wave

<span class="token keyword">def</span> <span class="token function">pcmToWav</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> out_file<span class="token punctuation">)</span><span class="token punctuation">:</span>

    in_file <span class="token operator">=</span> open<span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span>
    out_file <span class="token operator">=</span> wave<span class="token punctuation">.</span>open<span class="token punctuation">(</span>out_file<span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span>

    out_file<span class="token punctuation">.</span>setnchannels<span class="token punctuation">(</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"plese input channels [1/2]: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    out_file<span class="token punctuation">.</span>setframerate<span class="token punctuation">(</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"plese input samplerate [32000]: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    out_file<span class="token punctuation">.</span>setsampwidth<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#16-bit</span>
    out_file<span class="token punctuation">.</span>writeframesraw<span class="token punctuation">(</span>in_file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    in_file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    out_file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'complete'</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    IN_FILE <span class="token operator">=</span> input<span class="token punctuation">(</span>r<span class="token string">'input the file name: '</span><span class="token punctuation">)</span>
    OUT_FILE <span class="token operator">=</span> IN_FILE<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">'.wav'</span>

    pcmToWav<span class="token punctuation">(</span>IN_FILE<span class="token punctuation">,</span> OUT_FILE<span class="token punctuation">)</span>
    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'pause'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PCM 数据无法直接通过播放器打开，因为少了 44 字节的文件头，这里面最主要的信息是描述该 PCM 的采样频率，通道数，以及位数。&lt;/p&gt;
&lt;p&gt;双击 pcmToWav.exe，拖入待转换的 PCM 数据，输入通道数和采样频率，默认使用 16-bit 表示一个采样点。等待程序运行结束，就会生成一个同名的 .wav 文件。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="https://blog.cyang.tech/tags/python/"/>
    
      <category term="PCM" scheme="https://blog.cyang.tech/tags/PCM/"/>
    
  </entry>
  
  <entry>
    <title>文件转换为C数组 fileToC</title>
    <link href="https://blog.cyang.tech/2018/05/18/%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAC%E6%95%B0%E7%BB%84%20fileToC/"/>
    <id>https://blog.cyang.tech/2018/05/18/文件转换为C数组 fileToC/</id>
    <published>2018-05-18T05:34:23.000Z</published>
    <updated>2018-11-11T14:11:26.321Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="fileToC"><a href="#fileToC" class="headerlink" title="fileToC"></a>fileToC</h1><p><a href="https://github.com/cyang812/tools" target="_blank" rel="external">github项目地址</a></p>
<h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><p>fileToC 是一款使用 python 编写的程序，可以将任意文件的二进制数据转换为 .C 文件的数组，以便程序编译。</p>
<p>双击 fileToC.exe 程序，将要转换的 test.any 文件拖入命令行，等待程序自动转换，结束后便可以得到一个和该文件同名的 .c 文件</p>
<a id="more"></a>
<p>结果如下：test.any 文件的二进制数据</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/20180518132336617?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/20180518132349534?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这款程序的使用场景是当我们编程时，需要使用文件里面的部分或全部数据，而由于开发环境限制，无法通过文件的方式来读取，这在嵌入式系统中比较常见。那么，就可以通过将文件数据变成一个C文件，编译为常量，链接到程序中。<br>例如，程序中需要使用图片或音频数据，而又无法通过文件方式获得数据时，就可以这样使用。</p>
<p>实际上程序在转换时并不一次性将文件读入内存，而是分块进行转换，因此速度不是最快，但这可以减少内存的消耗，以支持更大的文件。另一方面，很多情况下，并不需要转换很大的文件。</p>
<p>同时，转换后的文件大小会是之前文件的6倍以上。这是因为，</p>
<pre><code>raw file: 0x17;  #这只是一个字节
.c  file: 0x17;_ #_表示空格，&#39;0&#39; &#39;x&#39; &#39;1&#39; &#39;7&#39; &#39;;&#39; &#39;_&#39; 共6个字节
</code></pre><p>但这只是 .c 文件的大小，编译后的程序中数据量和原文件大小是一样的。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>文件名不支持中文, 因为文件名作为数组名。另外文件名支持’-‘，但C语言不支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fileToC&quot;&gt;&lt;a href=&quot;#fileToC&quot; class=&quot;headerlink&quot; title=&quot;fileToC&quot;&gt;&lt;/a&gt;fileToC&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cyang812/tools&quot;&gt;github项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单说明&quot;&gt;&lt;a href=&quot;#简单说明&quot; class=&quot;headerlink&quot; title=&quot;简单说明&quot;&gt;&lt;/a&gt;简单说明&lt;/h2&gt;&lt;p&gt;fileToC 是一款使用 python 编写的程序，可以将任意文件的二进制数据转换为 .C 文件的数组，以便程序编译。&lt;/p&gt;
&lt;p&gt;双击 fileToC.exe 程序，将要转换的 test.any 文件拖入命令行，等待程序自动转换，结束后便可以得到一个和该文件同名的 .c 文件&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="python" scheme="https://blog.cyang.tech/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CSDN博客数据导出</title>
    <link href="https://blog.cyang.tech/2018/04/28/CSDN%E5%8D%9A%E5%AE%A2%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA/"/>
    <id>https://blog.cyang.tech/2018/04/28/CSDN博客数据导出/</id>
    <published>2018-04-28T06:46:23.000Z</published>
    <updated>2018-11-11T14:11:26.313Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h3 id="CSDN2HEXO-源码地址"><a href="#CSDN2HEXO-源码地址" class="headerlink" title="CSDN2HEXO 源码地址"></a><a href="https://github.com/cyang812/CSDN2HEXO" target="_blank" rel="external">CSDN2HEXO 源码地址</a></h3><h1 id="CSDN2HEXO"><a href="#CSDN2HEXO" class="headerlink" title="CSDN2HEXO"></a>CSDN2HEXO</h1><p>CSDN2HEXO 是一款基于<a href="http://open.csdn.net/" target="_blank" rel="external">CSDN开放平台</a> 的 csdn blog 内容下载器， 可以下载博客中的文章内容和图片，文章保存为 markdown 格式，图片可下载无水印图片，并根据文章标题生成文件夹存储相关数据。</p>
<a id="more"></a>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li><p>1、首先需要获得开发者认证，并创建应用，获取到 App_key 和 App_secret 以通过 OAuth2 认证，可<a href="http://open.csdn.net/apps/createapp" target="_blank" rel="external">在此获取</a></p>
</li>
<li><p>2、将 App_key，App_secret，CSDN_username，CSDN_secret 填入 <code>csdn_sdk.py</code> 文件开头处</p>
</li>
<li><p>3、运行 <code>csdn-spider.py</code></p>
</li>
</ul>
<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><ul>
<li><p>1、文章列表 </p>
<p>  <img src="http://p7tst3obo.bkt.clouddn.com/20180428144406106?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
<li><p>2、文章内容<br>  <img src="http://p7tst3obo.bkt.clouddn.com/20180428144425504?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>1、下载 csdn 博客的部分文章时，可能会出现返回的 json 数据仅为 <code>{&#39;status&#39;: True}</code>，此时文章内容无法获取。会将出错的文章id 和文章标题写到本地 <code>download_err.json</code> 文件。</p>
</li>
<li><p>2、如果是分析本地的 hexo 博客 markdown 文件，则运行 <code>md_parse.py</code>。可下载其中的无水印图片，并可替换图床，加入图片样式。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSDN2HEXO-源码地址&quot;&gt;&lt;a href=&quot;#CSDN2HEXO-源码地址&quot; class=&quot;headerlink&quot; title=&quot;CSDN2HEXO 源码地址&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/cyang812/CSDN2HEXO&quot;&gt;CSDN2HEXO 源码地址&lt;/a&gt;&lt;/h3&gt;&lt;h1 id=&quot;CSDN2HEXO&quot;&gt;&lt;a href=&quot;#CSDN2HEXO&quot; class=&quot;headerlink&quot; title=&quot;CSDN2HEXO&quot;&gt;&lt;/a&gt;CSDN2HEXO&lt;/h1&gt;&lt;p&gt;CSDN2HEXO 是一款基于&lt;a href=&quot;http://open.csdn.net/&quot;&gt;CSDN开放平台&lt;/a&gt; 的 csdn blog 内容下载器， 可以下载博客中的文章内容和图片，文章保存为 markdown 格式，图片可下载无水印图片，并根据文章标题生成文件夹存储相关数据。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="hexo" scheme="https://blog.cyang.tech/tags/hexo/"/>
    
      <category term="csdn" scheme="https://blog.cyang.tech/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>C语言中，隐藏结构体的细节</title>
    <link href="https://blog.cyang.tech/2018/04/18/C%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E9%9A%90%E8%97%8F%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>https://blog.cyang.tech/2018/04/18/C语言中，隐藏结构体的细节/</id>
    <published>2018-04-18T09:49:19.000Z</published>
    <updated>2018-11-11T14:11:26.313Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>本文转载自 <a href="https://www.cnblogs.com/qingergege/p/6882107.html" target="_blank" rel="external">博客园</a></p>
<p>我们都知道，在C语言中，结构体中的字段都是可以访问的。或者说，在C++ 中，类和结构体的主要区别就是<strong>类中成员变量默认为private，而结构体中默认为public</strong>。结构体的这一个特性，导致结构体中封装的数据，实际上并没有封装，外界都可以访问结构体中的字段。</p>
<a id="more"></a>
<p>C++中我们尚可用类来替代结构体，但是，C语言中是没有类的，只能用结构体，但很多时候，我们需要隐藏结构体的字段，<strong>不让外界直接访问，而是通过我们写的函数进行间接访问</strong>，这样就提高了程序的封装性。 </p>
<p>实现方法，简单来说，就是，结构体定义时，要定义在.c文件中，然后我们自己定义一些访问结构体的函数，在.h文件中，只存放函数原型声明和对结构体的声明。</p>
<p>看个例子<br>.c文件中</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//stu.c</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token keyword">struct</span> stu<span class="token punctuation">{</span>
    <span class="token keyword">char</span> id<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> score<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> stu <span class="token operator">*</span><span class="token function">new_stu</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> stu <span class="token operator">*</span>s<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> stu <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">set_id</span><span class="token punctuation">(</span><span class="token keyword">struct</span> stu <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token operator">-></span>id<span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token keyword">struct</span> stu <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，在.c文件中，我定义了一个结构体，并且定义了一些用于操作这个结构体的函数。</p>
<p>在.h文件中</p>
<pre class="line-numbers language-c"><code class="language-c">stu<span class="token punctuation">.</span>h
<span class="token macro property">#<span class="token directive keyword">ifndef</span> STU_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> STU_H</span>

<span class="token keyword">struct</span> stu<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">set_id</span><span class="token punctuation">(</span><span class="token keyword">struct</span> stu <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token keyword">struct</span> stu <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">extern</span> <span class="token keyword">struct</span> stu <span class="token operator">*</span><span class="token function">new_stu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在.h中我声明了一下结构体struct stu，并且写了函数的原型声明，供其他文件调用。</p>
<p>在main.c中我引用了stu.h</p>
<p>下面是main.c</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stu.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//struct stu s;</span>
    <span class="token comment" spellcheck="true">//s.score = 100;</span>
    <span class="token comment" spellcheck="true">//struct stu s = {{0}};</span>

    <span class="token keyword">struct</span> stu <span class="token operator">*</span>s<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token function">new_stu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">set_id</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"950621"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>id <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    id <span class="token operator">=</span> <span class="token function">get_id</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"设置的id为:%s\n"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，在main函数中，我先是定义了一个struct stu类型的指针，然后通过new_stu()给这个指针分配了空间，在通过另外两个函数对其进行了操作。</p>
<p>这里需要注意一下我注释掉的部分，说明一下：</p>
<p>这种情况下，<strong>不能定义struct stu类型的变量！！！</strong></p>
<p>因为：</p>
<p>.h文件中，<strong>只是对结构体进行了声明</strong>，并没有结构体具体细节的描述，也就是在main.c中只是声明了一下struct stu，这样编译器就知道有个结构体类型叫struct stu，<strong>但是它并不知道stu的内部细节</strong>。</p>
<p>我们都知道，定义一个变量，编译器是要给它<strong>分配内存空间的</strong>，但是，<strong>此时编译器并不知道stu的内部细节</strong>，也就不知道stu这个结构体的变量要占多少空间，自然无法分配内存。这样在编译时期就会报错。</p>
<p>但是定义一个指针变量就不一样啦，不管是什么类型的指针，占据的内存空间都是4个字节，编译器只需要确定有个叫struct stu 的类型存在就好了，而.h中那个声明，就是在告诉编译器，有这么一个类型。</p>
<p>同时，这种情况下也不能访问结构体的字段，比如，s-&gt;score=100;这条语句在编译时就会报错，原因和上面一样，<strong>编译器并不知道struct stu结构体的内部细节</strong>。</p>
<p>通过上面的方法，在除了stu.c文件之外的其他文件中，<strong>只能通过stu.c中定义的函数来间接操作结构体变量，而不能直接对结构体变量进行操作，</strong>包括不能创建一个结构体变量！</p>
<p>这样就很好地体现了程序的封装性，也提高了程序的安全性。但是就需要我们写很多操作函数啦，包括创建结构体指针变量分配空间的函数。</p>
<p>我们也可以在.h文件中用typedef声明一个结构体的指针类型，如  typedef struct sut * pStu;</p>
<p>这样在main.c中就可以用pStu声明结构体指针变量了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自 &lt;a href=&quot;https://www.cnblogs.com/qingergege/p/6882107.html&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，在C语言中，结构体中的字段都是可以访问的。或者说，在C++ 中，类和结构体的主要区别就是&lt;strong&gt;类中成员变量默认为private，而结构体中默认为public&lt;/strong&gt;。结构体的这一个特性，导致结构体中封装的数据，实际上并没有封装，外界都可以访问结构体中的字段。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言 符号的不同意义</title>
    <link href="https://blog.cyang.tech/2018/03/28/C%E8%AF%AD%E8%A8%80%20%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%B8%8D%E5%90%8C%E6%84%8F%E4%B9%89/"/>
    <id>https://blog.cyang.tech/2018/03/28/C语言 符号的不同意义/</id>
    <published>2018-03-28T14:15:23.000Z</published>
    <updated>2018-11-11T14:11:26.313Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>C语言的许多符号在不同的上下文环境里有不同的意义，相当于被“重载”了。如下展示了一些符号的不同意义。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>在函数内部，表示该变量的值在各个调用间一直保持延续性。类似与全局变量，区别在于作用域不同。</li>
<li>在函数外部，表示该函数或者变量只对本文件可见。</li>
</ul>
<a id="more"></a>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><ul>
<li>用于函数定义，表示全局可见（属于冗余，因为函数名在默认情况下具有外部的链接属性，如果函数没有在调用它的转换单元中定义，编译器就会把这个调用标记为外部，让链接程序处理它）</li>
<li>用于变量，表示它在其他地方定义(变量名和函数不同，当某个名称的定义对于当前转换单元来说是外部的。如果希望用一个名称访问当前装换单元外的变量，就必须用 extern 关键字来声明改变量，表示该名称在当前块的外部定义。之后编译器就把变量标记为具有外部链接属性，链接程序就会在名称和它的引用的变量之间建立链接。如果给定块中的一个名称有 extern 声明，就不能在同一个块中定义该名称)</li>
<li>一般而言，使用 extern 有2中方式：第一种是在 C 文件中直接声明某个其他文件中定义的函数或全局变量为 extern，从而告诉编译器这个函数或变量是在其他 C 文件中定义的；第二种是在头文件中声明某个函数或变量为 extern，然后在需要引用该函数或变量的 C 文件中包含这个头文件。第二种是比较好的方式，因为头文件只需要编写一次就可以在其他所有需要引用这些函数或变量的 C 文件中被包含，相应地如果函数定义或者变量的定义发生了变化，也只需要修改头文件一个文件就可以了，否则必须修改所有引用这些外部函数或变量的 C 文件。</li>
</ul>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><ul>
<li>作为函数的返回类型，表示不允许返回任何值</li>
<li>在指针声明中，表示通用指针的类型</li>
<li>位于参数列表中，表示没有参数</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><ul>
<li>乘法运算符</li>
<li>用于指针，间接引用</li>
<li>在声明中，表示指针</li>
</ul>
<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><ul>
<li>位的 AND 操作符</li>
<li>取地址符号</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title="()"></a>()</h2><ul>
<li>在函数定义中，包围形式参数表</li>
<li>调用一个函数</li>
<li>改变表达式的运算次序</li>
<li>将值转换为其他类型（强制类型转换）</li>
<li>定义带参数的宏</li>
<li>包围 sizeof 操作符的操作数</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>&lt;= 小于等于运算符</li>
<li>&lt;&lt;= 左移复合赋值运算符</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言的许多符号在不同的上下文环境里有不同的意义，相当于被“重载”了。如下展示了一些符号的不同意义。&lt;/p&gt;
&lt;h2 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在函数内部，表示该变量的值在各个调用间一直保持延续性。类似与全局变量，区别在于作用域不同。&lt;/li&gt;
&lt;li&gt;在函数外部，表示该函数或者变量只对本文件可见。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>IAR 和 Keil 使用外部 SDRAM 的区别</title>
    <link href="https://blog.cyang.tech/2018/03/26/IAR%20%E5%92%8C%20keil%20%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%20SDRAM%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://blog.cyang.tech/2018/03/26/IAR 和 keil 使用外部 SDRAM 的区别/</id>
    <published>2018-03-26T11:35:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>当芯片内部的 SRAM 不够用时，就需要在外部扩展 SDRAM，然后在写程序时将一些比较大的 buffer 定义在外部内存中。在进行正确的配置之后，对外部 SDRAM 的使用，和芯片内部的 SRAM 是一样的，可以直接对 SDRAM 的地址进行读写访问。</p>
<a id="more"></a>
<p>因此，最简单的方法就是，如下所示的代码，直接使用指针指到外部 SDRAM 的地址，之后对指针进行移动，便可以对全部 SDRAM 进行读写。使用这种方法需要特别小心，要确保指针指向的地址在 SDRAM 的地址空间。</p>
<pre class="line-numbers language-c"><code class="language-c">uint8_t <span class="token operator">*</span>sdram_buf <span class="token operator">=</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>SDRAM_ADDR<span class="token punctuation">;</span>
uint8_t <span class="token operator">*</span>sdram_ptr <span class="token operator">=</span> sdram_buf<span class="token punctuation">;</span>
uint32_t sdram_useSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
uint8_t sdram_full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外的一种方法就是，将 buffer 数组定义在外部 SDRAM 中，这样可将指针操作改为对数组的操作。也就是在定义数组时，不是由编译器自动分配地址，而是手动指定数组的地址。不同的 IDE 语法不一样，在 IAR 下，需要使用如下的语句，</p>
<pre class="line-numbers language-c"><code class="language-c">IAR 在外部SDRAM定义数组的方法
<span class="token macro property">#<span class="token directive keyword">pragma</span> location = SDRAM_ADDR</span>
uint8_t sdram_buffer<span class="token punctuation">[</span><span class="token number">0x700000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译后生成的 map 文件可以看出，有 7MB 的空间是使用绝对地址定义的。<br><img src="http://p7tst3obo.bkt.clouddn.com/20180326193029821?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<p>keil 下使用如下语句：</p>
<pre class="line-numbers language-c"><code class="language-c">keil 在外部SDRAM定义数组的方法
uint8_t sdram_buffer<span class="token punctuation">[</span><span class="token number">0x700000</span><span class="token punctuation">]</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token function">at</span><span class="token punctuation">(</span>SDRAM_ADDR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当芯片内部的 SRAM 不够用时，就需要在外部扩展 SDRAM，然后在写程序时将一些比较大的 buffer 定义在外部内存中。在进行正确的配置之后，对外部 SDRAM 的使用，和芯片内部的 SRAM 是一样的，可以直接对 SDRAM 的地址进行读写访问。&lt;/p&gt;
    
    </summary>
    
      <category term="硬件" scheme="https://blog.cyang.tech/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="STM32" scheme="https://blog.cyang.tech/tags/STM32/"/>
    
      <category term="IAR" scheme="https://blog.cyang.tech/tags/IAR/"/>
    
      <category term="keil" scheme="https://blog.cyang.tech/tags/keil/"/>
    
  </entry>
  
  <entry>
    <title>C语言 ringBuffer</title>
    <link href="https://blog.cyang.tech/2018/03/22/C%E8%AF%AD%E8%A8%80%20ringBuffer/"/>
    <id>https://blog.cyang.tech/2018/03/22/C语言 ringBuffer/</id>
    <published>2018-03-22T12:32:23.000Z</published>
    <updated>2018-11-11T14:11:26.313Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="一、-ringBuffer-介绍"><a href="#一、-ringBuffer-介绍" class="headerlink" title="一、 ringBuffer 介绍"></a>一、 ringBuffer 介绍</h1><p>ringBuffer 称作环形缓冲，也有叫 circleBuffer 的。就是取内存中一块连续的区域用作环形缓冲区的数据存储区。这块连续的存储会被反复使用，向 ringBuffer 写入数据总是从写指针的位置开始，如写到实际存储区的末尾还没有写完，则将剩余的数据从存储区的头开始写；从该 ringBuffer 读出数据也是从读指针的位置开始，如读到实际存储区的末尾还没有读完，则从存储区的头开始读剩下的数据。</p>
<a id="more"></a>
<p>为了保证写入的数据不会覆盖 ringBuffer 里还没有被读出的数据，以及读出的数据不是已经读出过的旧数据，需要使用一个变量 btoRead 表示该 ringBuffer 中有效的数据。使用变量 length 表示该环形缓冲区中真实的缓冲大小。使用指针 source 指向实际的缓存地址。</p>
<p>使用 ringBuffer 读写数据，要确保读写数据的速率和实际缓冲区大小的匹配。如果不匹配，可能会导致溢出，比如读数据太慢，而写数据很快，实际的缓存区又太小，导致整个缓冲区都是还没有被读出的数据，此时新的数据就无法写入。正确使用 ringBuffer 可以保证数据的连续，降低读模块和写模块之间的耦合性。更多关于生产者-消费者模型的知识可以看这篇<a href="https://blog.csdn.net/lenyusun/article/details/6609786" target="_blank" rel="external">博客</a>。</p>
<h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><p>ringBuffer 的结构体</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    uint8_t <span class="token operator">*</span>source<span class="token punctuation">;</span>
    uint32_t br<span class="token punctuation">;</span>
    uint32_t bw<span class="token punctuation">;</span>
    uint32_t btoRead<span class="token punctuation">;</span>
    uint32_t length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ringbuffer_t<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 ringBuffer 函数</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">create_ringBuffer</span><span class="token punctuation">(</span>ringbuffer_t <span class="token operator">*</span>ringBuf<span class="token punctuation">,</span> uint8_t <span class="token operator">*</span>buf<span class="token punctuation">,</span> uint32_t buf_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ringBuf<span class="token operator">-></span>br         <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>bw         <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>btoRead    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>source     <span class="token operator">=</span> buf<span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>length     <span class="token operator">=</span> buf_len<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create ringBuffer->length = %d\n"</span><span class="token punctuation">,</span> ringBuf<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>清空 ringBuffer 函数</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">clear_ringBuffer</span><span class="token punctuation">(</span>ringbuffer_t <span class="token operator">*</span>ringBuf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ringBuf<span class="token operator">-></span>br         <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>bw         <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>btoRead    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//no need do this casue r_ptr and w_prt has change</span>
<span class="token comment" spellcheck="true">//    memset((uint8_t *)ringBuf->source, 0, ringBuf->length); </span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>读数据函数</p>
<pre class="line-numbers language-c"><code class="language-c">uint32_t <span class="token function">write_ringBuffer</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>buffer<span class="token punctuation">,</span> uint32_t size<span class="token punctuation">,</span> ringbuffer_t <span class="token operator">*</span>ringBuf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uint32_t len            <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    uint32_t ringBuf_bw     <span class="token operator">=</span> ringBuf<span class="token operator">-></span>bw<span class="token punctuation">;</span>
    uint32_t ringBuf_len    <span class="token operator">=</span> ringBuf<span class="token operator">-></span>length<span class="token punctuation">;</span>
    uint8_t <span class="token operator">*</span>ringBuf_source <span class="token operator">=</span> ringBuf<span class="token operator">-></span>source<span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>ringBuf_bw <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> ringBuf_len  <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>ringBuf_source <span class="token operator">+</span> ringBuf_bw<span class="token punctuation">,</span> bufff<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        len <span class="token operator">=</span> ringBuf_len <span class="token operator">-</span> ringBuf_bw<span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>ringBuf_source <span class="token operator">+</span> ringBuf_bw<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>ringBuf_source<span class="token punctuation">,</span> buffer <span class="token operator">+</span> ringBuf_bw<span class="token punctuation">,</span> size <span class="token operator">-</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ringBuf<span class="token operator">-></span>bw <span class="token operator">=</span> <span class="token punctuation">(</span>ringBuf<span class="token operator">-></span>bw <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">%</span> ringBuf_len<span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>btoRead <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span>

    <span class="token keyword">return</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>写数据函数</p>
<pre class="line-numbers language-c"><code class="language-c">uint32_t <span class="token function">read_ringBuffer</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>buffer<span class="token punctuation">,</span> uint32_t size<span class="token punctuation">,</span> ringbuffer_t <span class="token operator">*</span>ringBuf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uint32_t len            <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    uint32_t ringBuf_br     <span class="token operator">=</span> ringBuf<span class="token operator">-></span>br<span class="token punctuation">;</span>
    uint32_t ringBuf_len    <span class="token operator">=</span> ringBuf<span class="token operator">-></span>length<span class="token punctuation">;</span>
    uint8_t <span class="token operator">*</span>ringBuf_source <span class="token operator">=</span> ringBug<span class="token operator">-></span>source<span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>ringBuf_br <span class="token operator">+</span> size <span class="token punctuation">)</span> <span class="token operator">&lt;=</span> ringBuf_len <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> ringBuf_source <span class="token operator">+</span> ringBuf_br<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        len <span class="token operator">=</span> ringBuf_len <span class="token operator">-</span> ringBuf_br<span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>bufff<span class="token punctuation">,</span> ringBuf_source <span class="token operator">+</span> ringBuf_br<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer <span class="token operator">+</span> len<span class="token punctuation">,</span> ringBuf_source<span class="token punctuation">,</span> size <span class="token operator">-</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ringBuf<span class="token operator">-></span>br <span class="token operator">=</span> <span class="token punctuation">(</span>ringBuf<span class="token operator">-></span>br <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">%</span> ringBuf_len<span class="token punctuation">;</span>
    ringBuf<span class="token operator">-></span>btoRead <span class="token operator">-</span><span class="token operator">=</span> size<span class="token punctuation">;</span>

    <span class="token keyword">return</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取 ringBuffer 中的有效数据</p>
<pre class="line-numbers language-c"><code class="language-c">uint32_t <span class="token function">get_ringBuffer_btoRead</span><span class="token punctuation">(</span>ringbuffer_t <span class="token operator">*</span>ringBuf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> ringBuf<span class="token operator">-></span>btoRead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取 ringBuffer 的长度</p>
<pre class="line-numbers language-c"><code class="language-c">uint32_t <span class="token function">get_ringBuffer_length</span><span class="token punctuation">(</span>ringbuffer_t <span class="token operator">*</span>ringBuf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> ringBuf<span class="token operator">-></span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h1><p>对 ringBuffer 的使用，首先需要又一块真实并且连续的数据存储区。可以使用 malloc 从堆区分配，也可以使用一个数组。</p>
<p>在写数据之前，需要对此时 ringBuffer 的剩余空间和要写入数据的大小进行比较。剩余空间使用长度 length 减去待读出数据量 btoRead 得到。</p>
<p>在读出数据之前，则需要对此时 ringBuffer 可读出的有效数据 btoRead 进行判断。</p>
<p>读出的数据不够，或者没有足够的空间写如数据，可以在调用读写函数之前进行判断，假如情况不满足，就不调用相应的读写函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、-ringBuffer-介绍&quot;&gt;&lt;a href=&quot;#一、-ringBuffer-介绍&quot; class=&quot;headerlink&quot; title=&quot;一、 ringBuffer 介绍&quot;&gt;&lt;/a&gt;一、 ringBuffer 介绍&lt;/h1&gt;&lt;p&gt;ringBuffer 称作环形缓冲，也有叫 circleBuffer 的。就是取内存中一块连续的区域用作环形缓冲区的数据存储区。这块连续的存储会被反复使用，向 ringBuffer 写入数据总是从写指针的位置开始，如写到实际存储区的末尾还没有写完，则将剩余的数据从存储区的头开始写；从该 ringBuffer 读出数据也是从读指针的位置开始，如读到实际存储区的末尾还没有读完，则从存储区的头开始读剩下的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="ringBuffer" scheme="https://blog.cyang.tech/tags/ringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>C语言 Malloc 内存泄漏</title>
    <link href="https://blog.cyang.tech/2018/03/18/C%E8%AF%AD%E8%A8%80%20malloc%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://blog.cyang.tech/2018/03/18/C语言 malloc 内存泄漏/</id>
    <published>2018-03-18T12:34:23.000Z</published>
    <updated>2018-11-11T14:11:26.313Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>错误代码如下：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Init_layer2_Decoder</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Stream <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> mad_stream<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mad_stream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Frame <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> mad_frame<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mad_frame<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Synth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> mad_synth<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mad_synth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>Stream<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">||</span> Frame<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">||</span> Synth<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"init mp2Dec fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">mad_stream_init</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mad_frame_init</span><span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mad_synth_init</span><span class="token punctuation">(</span>Synth<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<a id="more"></a>
<p>这个函数先为三个结构体变量申请内存空间，其中一个申请失败就返回失败。如果全都申请成功的话，就对结构体变量进行初始化工作。逻辑上似乎没有什么问题，但是这里隐藏了一个内存泄漏的错误。</p>
<p>假如 <code>Stream</code> 申请成功，<code>Frame</code> 申请失败，满足 if 语句的条件，函数不再继续执行，返回-1。可是 <code>Stream</code> 所指向的空间并不会被释放到堆区。这就造成了内存泄漏。类似的情况还有，<code>Stream</code> 和 <code>Frame</code> 均申请成功，但是 <code>Synth</code> 申请失败，此时直接返回，必定会造成内存没有被释放。因此，代码应该做如下修改：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Init_layer2_Decoder</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Stream <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> mad_stream<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mad_stream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Stream <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    Frame <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> mad_frame<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mad_frame<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Frame <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Stream <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Synth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> mad_synth<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mad_synth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Synth <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Stream <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        Frame <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    

    <span class="token function">mad_stream_init</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mad_frame_init</span><span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mad_synth_init</span><span class="token punctuation">(</span>Synth<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里假设 Frame 大小为100k，整个堆区为75k，因此 Steam 可以申请成功，但 Frame 显然会申请失败。如果不对 Frame 进行释放就直接返回的话，就会造成内存泄漏。如下串口打印可看。</p>
<pre><code>**********************
SystemCoreClock = 180000000
sizeof(Stream) = 56
Stream = 0x20003b30
malloc Frame fail!
//free(Stream)
Stream = 0x20003b30
init mp2 dec fail!
---------------------------
total free space = 76736, 74 k
max system bytes =      76800
system bytes     =      76800
in use bytes     =         64
</code></pre><p>从上面的结果可以看到，Stream 的结构大小为56字节，加上必要的用于维护的数据，在堆区占用了64字节， Frame 申请失败后，可看到这64字节并没有被释放。</p>
<p>另外，在对 Stream 进行释放之后，还要将该指针指向 NULL。因为释放只是将该指针指向的内存还给堆区，Stream 指针还是指向堆区，但此时对该指针的指向的区域进行访问是不被允许的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int Init_layer2_Decoder(void)
{
    Stream = (struct mad_stream*)malloc(sizeof(struct mad_stream));
    Frame = (struct mad_frame*)malloc(sizeof(struct mad_frame));
    Synth = (struct mad_synth*)malloc(sizeof(struct mad_synth));

    if(Stream==NULL || Frame==NULL || Synth==NULL)
    {
        printf(&amp;quot;init mp2Dec fail!\n&amp;quot;);
        return -1;
    }

    mad_stream_init(Stream);
    mad_frame_init(Frame);
    mad_synth_init(Synth);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.cyang.tech/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C语言" scheme="https://blog.cyang.tech/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>STM32 硬件CRC和软件CRC速度比较</title>
    <link href="https://blog.cyang.tech/2018/03/12/STM32%20%E7%A1%AC%E4%BB%B6CRC%E5%92%8C%E8%BD%AF%E4%BB%B6CRC%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83/"/>
    <id>https://blog.cyang.tech/2018/03/12/STM32 硬件CRC和软件CRC速度比较/</id>
    <published>2018-03-12T14:49:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="一、测试条件"><a href="#一、测试条件" class="headerlink" title="一、测试条件"></a>一、测试条件</h1><p>硬件： STM32L432KC<br>主频： 80MHz<br>编译器： IAR 8.20.1<br>编译选项： High Speed no size constraints<br>CRC 生成多项式： 0x782f</p>
<h1 id="二、测试方法"><a href="#二、测试方法" class="headerlink" title="二、测试方法"></a>二、测试方法</h1><p>软件提前生成CRC表，用于查询。分别使用软件CRC算法和硬件CRC外设对一个缓存进行计算，目的是从该缓存中找到同步头。同步头共11字节，前两个字节为后九个字节的CRC校验值。通过迭代算法依次对11字节进行计算和比较，当找到同步头后返回同步头偏移量。通过时间比较两者之间的速度。</p>
<h1 id="三、测试结果"><a href="#三、测试结果" class="headerlink" title="三、测试结果"></a>三、测试结果</h1><p>迭代24464次后，从缓存中找到同步头。<br>不开启编译时间优化时，软件算法用时238ms，硬件CRC用时220ms。<br><img src="http://p7tst3obo.bkt.clouddn.com/20180312224132752?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<a id="more"></a>
<p>开启编译时间优化后，软件算法用时159ms，硬件CRC用时186ms。<br><img src="http://p7tst3obo.bkt.clouddn.com/20180312224305220?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<h1 id="四、附测试代码"><a href="#四、附测试代码" class="headerlink" title="四、附测试代码"></a>四、附测试代码</h1><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"user_crc.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32l4xx_hal.h"</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> SOFT_CRC  1</span>
<span class="token macro property">#<span class="token directive keyword">define</span> HARD_CRC  2</span>

CRC_HandleTypeDef   CrcHandle<span class="token punctuation">;</span>
uint16_t crc_tab<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">crc_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*##-1- Configure the CRC peripheral #######################################*/</span>
    CrcHandle<span class="token punctuation">.</span>Instance <span class="token operator">=</span> CRC<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* The default polynomial is not used. It is required to defined it in CrcHandle.Init.GeneratingPolynomial*/</span>    
    CrcHandle<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>DefaultPolynomialUse      <span class="token operator">=</span> DEFAULT_POLYNOMIAL_DISABLE<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* Set the value of the polynomial */</span>
    CrcHandle<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>GeneratingPolynomial      <span class="token operator">=</span> CRC_POLYNOMIAL_16B<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* The user-defined generating polynomial generates a
         16-bit long CRC */</span>
    CrcHandle<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>CRCLength                 <span class="token operator">=</span> CRC_POLYLENGTH_16B<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* The default init value is used */</span>
    CrcHandle<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>DefaultInitValueUse         <span class="token operator">=</span> DEFAULT_INIT_VALUE_DISABLE<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* The input data are not inverted */</span>
    CrcHandle<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>InputDataInversionMode    <span class="token operator">=</span> CRC_INPUTDATA_INVERSION_NONE<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* The output data are not inverted */</span>
    CrcHandle<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>OutputDataInversionMode   <span class="token operator">=</span> CRC_OUTPUTDATA_INVERSION_DISABLE<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* The input data are 8-bit long */</span>
    CrcHandle<span class="token punctuation">.</span>InputDataFormat                  <span class="token operator">=</span> CRC_INPUTDATA_FORMAT_BYTES<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_CRC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>CrcHandle<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* Initialization Error */</span>
        <span class="token function">Error_Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">crc_buildTab</span><span class="token punctuation">(</span>uint16_t gen_polynom<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> value <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> value<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        uint16_t crc <span class="token operator">=</span> value <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>crc <span class="token operator">&amp;</span> <span class="token number">0x8000</span><span class="token punctuation">)</span>
                crc <span class="token operator">=</span> <span class="token punctuation">(</span>crc <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> gen_polynom<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                crc <span class="token operator">=</span> crc <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        crc_tab<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> crc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

uint16_t <span class="token function">soft_crc_calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint8_t <span class="token operator">*</span>data<span class="token punctuation">,</span> uint16_t len<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    uint16_t crc <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>uint16_t offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> offset<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        crc <span class="token operator">=</span> <span class="token punctuation">(</span>crc <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">^</span> crc_tab<span class="token punctuation">[</span><span class="token punctuation">(</span>crc <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">^</span> data<span class="token punctuation">[</span>offset<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> crc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

uint16_t <span class="token function">hard_crc_calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint8_t <span class="token operator">*</span>data<span class="token punctuation">,</span> uint16_t len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uint16_t crc <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">;</span>

    crc <span class="token operator">=</span> <span class="token function">HAL_CRC_Calculate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>CrcHandle<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint32_t <span class="token operator">*</span><span class="token punctuation">)</span>data<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> crc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

uint16_t <span class="token function">find_sync_word</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>data<span class="token punctuation">,</span> uint32_t data_len<span class="token punctuation">,</span> uint8_t crc_type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uint8_t <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
    uint16_t crc_stored<span class="token punctuation">,</span>crc_calced<span class="token punctuation">;</span>

    ptr <span class="token operator">=</span> data<span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>uint32_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>data_len<span class="token number">-9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        crc_stored <span class="token operator">=</span> ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">|</span> ptr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>crc_type <span class="token operator">==</span> SOFT_CRC<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            crc_calced <span class="token operator">=</span> <span class="token function">soft_crc_calc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>crc_type <span class="token operator">==</span> HARD_CRC<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            crc_calced <span class="token operator">=</span> <span class="token function">hard_crc_calc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>crc_stored <span class="token operator">!=</span> <span class="token number">0x0000</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>crc_stored <span class="token operator">==</span> crc_calced<span class="token punctuation">)</span> <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"crc check ok! crc1 = 0x%04x,crc2 = 0x%04x\n"</span><span class="token punctuation">,</span> crc_stored<span class="token punctuation">,</span>crc_calced<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        ptr<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token function">crc_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uint32_t tick1<span class="token punctuation">,</span>tick2<span class="token punctuation">;</span>
    uint32_t find_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    uint16_t gen_polynom <span class="token operator">=</span> <span class="token number">0x782f</span><span class="token punctuation">;</span>

    <span class="token function">crc_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">crc_buildTab</span><span class="token punctuation">(</span>gen_polynom<span class="token punctuation">)</span><span class="token punctuation">;</span>

    tick1 <span class="token operator">=</span> <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    find_cnt <span class="token operator">=</span> <span class="token function">find_sync_word</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>superFrameBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>superFrameBuf<span class="token punctuation">)</span><span class="token punctuation">,</span> SOFT_CRC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tick2 <span class="token operator">=</span> <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"use soft_crc find sync word after %d iteration, use time %d\n"</span><span class="token punctuation">,</span> find_cnt<span class="token punctuation">,</span> tick2 <span class="token operator">-</span> tick1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    tick1 <span class="token operator">=</span> <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    find_cnt <span class="token operator">=</span> <span class="token function">find_sync_word</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>superFrameBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>superFrameBuf<span class="token punctuation">)</span><span class="token punctuation">,</span> HARD_CRC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tick2 <span class="token operator">=</span> <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"use hard_crc find sync word after %d iteration, use time %d\n"</span><span class="token punctuation">,</span> find_cnt<span class="token punctuation">,</span> tick2 <span class="token operator">-</span> tick1<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、测试条件&quot;&gt;&lt;a href=&quot;#一、测试条件&quot; class=&quot;headerlink&quot; title=&quot;一、测试条件&quot;&gt;&lt;/a&gt;一、测试条件&lt;/h1&gt;&lt;p&gt;硬件： STM32L432KC&lt;br&gt;主频： 80MHz&lt;br&gt;编译器： IAR 8.20.1&lt;br&gt;编译选项： High Speed no size constraints&lt;br&gt;CRC 生成多项式： 0x782f&lt;/p&gt;
&lt;h1 id=&quot;二、测试方法&quot;&gt;&lt;a href=&quot;#二、测试方法&quot; class=&quot;headerlink&quot; title=&quot;二、测试方法&quot;&gt;&lt;/a&gt;二、测试方法&lt;/h1&gt;&lt;p&gt;软件提前生成CRC表，用于查询。分别使用软件CRC算法和硬件CRC外设对一个缓存进行计算，目的是从该缓存中找到同步头。同步头共11字节，前两个字节为后九个字节的CRC校验值。通过迭代算法依次对11字节进行计算和比较，当找到同步头后返回同步头偏移量。通过时间比较两者之间的速度。&lt;/p&gt;
&lt;h1 id=&quot;三、测试结果&quot;&gt;&lt;a href=&quot;#三、测试结果&quot; class=&quot;headerlink&quot; title=&quot;三、测试结果&quot;&gt;&lt;/a&gt;三、测试结果&lt;/h1&gt;&lt;p&gt;迭代24464次后，从缓存中找到同步头。&lt;br&gt;不开启编译时间优化时，软件算法用时238ms，硬件CRC用时220ms。&lt;br&gt;&lt;img src=&quot;http://p7tst3obo.bkt.clouddn.com/20180312224132752?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="编程" scheme="https://blog.cyang.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STM32" scheme="https://blog.cyang.tech/tags/STM32/"/>
    
      <category term="IAR" scheme="https://blog.cyang.tech/tags/IAR/"/>
    
  </entry>
  
  <entry>
    <title>下载 Tumblr 标记为喜欢的内容</title>
    <link href="https://blog.cyang.tech/2018/03/03/%E4%B8%8B%E8%BD%BD%20tumblr%20%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>https://blog.cyang.tech/2018/03/03/下载 tumblr 标记为喜欢的内容/</id>
    <published>2018-03-03T08:54:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>源代码发布在github : <a href="https://github.com/cyang812/get_tumblr_likes" target="_blank" rel="external">get_tumblr_likes</a></p>
<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>本项目使用 python 编写，分析 tumblr 账户中喜欢的内容，给出资源链接，并下载。<br>其中 <code>test.json</code> 是一份 tumblr 返回的喜欢数据的 json 示例，提取里面图片和视频的资源地址后下载，下载的内容如下图。</p>
<p><img src="http://p7tst3obo.bkt.clouddn.com/20180303164838919?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<a id="more"></a>
<h1 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h1><ul>
<li><p>首先，你需要通过 tumblr API 来获取账户喜欢内容。这个过程是需要通过 OAuth 认证的，具体可参看<a href="https://www.tumblr.com/docs/en/api/v2#auth" target="_blank" rel="external">这个网页</a></p>
</li>
<li><p>得到认证后可以通过脚本来获取资源内容，也可以通过<a href="https://api.tumblr.com/console/calls/user/likes#" target="_blank" rel="external">这个网页</a>来查询，结果会通过 json 的形式返回</p>
</li>
<li><p>保存你得到的 json 数据，命名为<code>test.json</code>，执行命令 <code>python json_parse.py</code>，这可以从 json 文件中提取出资源的真正链接，并存为 <code>url_list.txt</code> 文件<br><img src="http://p7tst3obo.bkt.clouddn.com/20180303164909831?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
<li><p>执行 <code>python download.py</code>，之后资源文件就会挨个下载到 download 文件夹下<br><img src="http://p7tst3obo.bkt.clouddn.com/20180303164920621?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
</li>
</ul>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><ul>
<li><p>由于众所周知的原因，tumblr 的资源地址是不能直接下载的，因此需要设置代理。测试时使用 ssr 代理本地连接，因此 <code>download.py</code> 中有 <code>PROXIES = { &quot;http&quot;: &quot;http://127.0.0.1:1080&quot;, &quot;https&quot;: &quot;https://127.0.0.1:1080&quot; }</code>，如果是在可直接访问 tumblr 的 VPS 上运行，可对代码做如下修改。</p>
<pre class="line-numbers language-python"><code class="language-python">  <span class="token comment" spellcheck="true"># r = requests.get(url,proxies=PROXIES) # use proxy</span>
  r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true"># directly access</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>这个项目下载的是账户中的喜欢内容，因此需要进行认证。如果是下载某个账户发布的内容，可使用<a href="https://github.com/dixudx/tumblr-crawler" target="_blank" rel="external">tumblr-crawler</a>，再次感谢 tumblr-crawler 项目</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源代码发布在github : &lt;a href=&quot;https://github.com/cyang812/get_tumblr_likes&quot;&gt;get_tumblr_likes&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;p&gt;本项目使用 python 编写，分析 tumblr 账户中喜欢的内容，给出资源链接，并下载。&lt;br&gt;其中 &lt;code&gt;test.json&lt;/code&gt; 是一份 tumblr 返回的喜欢数据的 json 示例，提取里面图片和视频的资源地址后下载，下载的内容如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7tst3obo.bkt.clouddn.com/20180303164838919?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://blog.cyang.tech/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://blog.cyang.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://blog.cyang.tech/tags/python/"/>
    
      <category term="tumblr" scheme="https://blog.cyang.tech/tags/tumblr/"/>
    
  </entry>
  
  <entry>
    <title>STM32 无法通过 百分号F 打印浮点数</title>
    <link href="https://blog.cyang.tech/2018/03/03/STM32%20%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%20%E7%99%BE%E5%88%86%E5%8F%B7f%20%E6%89%93%E5%8D%B0%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://blog.cyang.tech/2018/03/03/STM32 无法通过 百分号f 打印浮点数/</id>
    <published>2018-03-03T06:01:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h1><p>使用 IAR 开发 STM32，发现无法通过 printf 重定向到串口打印出浮点数。代码如下：<br><img src="http://p7tst3obo.bkt.clouddn.com/20180302144541975?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<a id="more"></a>
<p>输出结果如下：<br><img src="http://p7tst3obo.bkt.clouddn.com/20180302144722631?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<p>可见，浮点数部分无法正常显示。</p>
<h1 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h1><p>这是由于 IAR 默认选择的 printf 库不支持浮点数的的输出。可在设置选项中修改。如下：默认使用 small，改为 auto 即可。<br><img src="http://p7tst3obo.bkt.clouddn.com/20180302144931419?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
<h1 id="三、备注"><a href="#三、备注" class="headerlink" title="三、备注"></a>三、备注</h1><p>在不修改设置的情况下，尝试过如下两种代码解决。一种是通过 sprintf 将浮点数转换成字符串输出，另一种是分解整数和小数部分，分别输出。第一种方法也是不可行的，只有分解可以。</p>
<p>代码如下：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*
* cyang 2018/2/27
* mcu printf float value
*/</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">printf_float</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> tmp<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> <span class="token string">"%f"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">PrintFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> tmp<span class="token punctuation">,</span>tmp1<span class="token punctuation">,</span>tmp2<span class="token punctuation">,</span>tmp3<span class="token punctuation">,</span>tmp4<span class="token punctuation">,</span>tmp5<span class="token punctuation">,</span>tmp6<span class="token punctuation">;</span>
    tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
    tmp1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
    tmp2<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
    tmp3<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
    tmp4<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
    tmp5<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
    tmp6<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"f-value=%d.%d%d%d%d%d%d\r\n"</span><span class="token punctuation">,</span>tmp<span class="token punctuation">,</span>tmp1<span class="token punctuation">,</span>tmp2<span class="token punctuation">,</span>tmp3<span class="token punctuation">,</span>tmp4<span class="token punctuation">,</span>tmp5<span class="token punctuation">,</span>tmp6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* code */</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">2.354954</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %f\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf_float</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintFloat</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、问题&quot;&gt;&lt;a href=&quot;#一、问题&quot; class=&quot;headerlink&quot; title=&quot;一、问题&quot;&gt;&lt;/a&gt;一、问题&lt;/h1&gt;&lt;p&gt;使用 IAR 开发 STM32，发现无法通过 printf 重定向到串口打印出浮点数。代码如下：&lt;br&gt;&lt;img src=&quot;http://p7tst3obo.bkt.clouddn.com/20180302144541975?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="编程" scheme="https://blog.cyang.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STM32" scheme="https://blog.cyang.tech/tags/STM32/"/>
    
      <category term="IAR" scheme="https://blog.cyang.tech/tags/IAR/"/>
    
  </entry>
  
  <entry>
    <title>STM32L432 CoreMark跑分测试</title>
    <link href="https://blog.cyang.tech/2018/03/01/STM32L432%20CoreMark%E8%B7%91%E5%88%86%E6%B5%8B%E8%AF%95/"/>
    <id>https://blog.cyang.tech/2018/03/01/STM32L432 CoreMark跑分测试/</id>
    <published>2018-03-01T14:08:23.000Z</published>
    <updated>2018-11-11T14:11:26.317Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>测试环境： IAR for ARM 7.80.4</p>
<p>测试得分：277<br>官方给出的分数为：273.55<br>如下图：<br><img src="http://p7tst3obo.bkt.clouddn.com/20180228125429924?imageView2/0/interlace/1/q/100|watermark/2/text/Y3lhbmcudGVjaA==/font/Y29uc29sYXM=/fontsize/720/fill/I0Q0RUVGMQ==/dissolve/69/gravity/SouthEast/dx/10/dy/10" alt="这里写图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;测试环境： IAR for ARM 7.80.4&lt;/p&gt;
&lt;p&gt;测试得分：
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.cyang.tech/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="编程" scheme="https://blog.cyang.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STM32" scheme="https://blog.cyang.tech/tags/STM32/"/>
    
      <category term="IAR" scheme="https://blog.cyang.tech/tags/IAR/"/>
    
      <category term="CoreMark" scheme="https://blog.cyang.tech/tags/CoreMark/"/>
    
  </entry>
  
</feed>
